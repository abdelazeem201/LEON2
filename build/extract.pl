#!/usr/bin/perl

if ($#ARGV < 1) {
    die ("# Call: extract.pl <config> <basedir> \n");
}
$config = $ARGV[0];

$base = $ARGV[1];
$cmd = "find $base";
print STDERR $cmd;
$a = `$cmd`;
@a = split("\n",$a);
%h = ();
%d = ();

foreach $f (@a) {
    if ( $f =~ /\.vhd$/) {
	($fn,$pn) = splitpath($f);
	if ($fn =~ /^([^\.]*)\.vhd$/) {
	    $h{$1} = $f;
	}
    }
}

%trans = ();
%noread = ();
if (open(FILEH, "$config")) {
    while (<FILEH>) {
	@c = split("=",$_);
	if ($#c == 1) {
	    $k = $c[0];
	    $v = $c[1];
	    $k =~ s/[\s\n\r]//gi;
	    $v =~ s/[\s\n\r]//gi;
	    if (exists($h{$k})) {
		if ($v =~ /trans/) {
		    $n = $h{$k};
		    @tmp = ();
		    $trans{$n} = [@tmp];
		} elsif ($v =~ /exclude/) {
		    $n = $h{$k};
		    $noread{$n} = 1;
		}
	    }
	}
    }
    close(FILEH);
} else {
    die ("opening \"$config\": $!\n");
}


foreach $f (@a) {
    $dep = "$f: ";
    if ( $f =~ /\.vhd$/) {
	if (1) { #if (!$noread{$f}){
	    ($fn,$pn) = splitpath($f);
	    if (open(FILEH, "$f")) {
		@tmp = ();
		$d{$f} = [@tmp];
		print STDERR ("Scanning $f\n");
		while (<FILEH>) {
		    if (!(/\$\(do-not-add-to-makefile\)/)) {
			if (/use[[:space:]]*work\.([[:print:]]*)\.all/) {
			    $m = $1;
			    $m =~ s/[\s\r\n]$//;
			    if (exists($h{$m})) {
				$m = $h{$m};
				@tmp = @{$d{$f}};
				push(@tmp,$m);
				$d{$f} = [@tmp];
			    }
			}
			elsif (/component [[:space:]]*([[:print:]]*)/) {
			    $m = $1;
			    $m =~ s/[\s\r\n]$//;
			    if (exists($trans{$f})) {
				@tmp = @{$trans{$f}};
				if (exists($h{$m})) {
				    $m = $h{$m};
				    push (@tmp,$m);
				    $trans{$f} = [@tmp];
				}
			    } else {
				if (exists($h{$m})) {
				    $m = $h{$m};
				    @tmp = @{$d{$f}};
				    push(@tmp,$m);
				    $d{$f} = [@tmp];
				}
			    } 
			}
		    } 
		    
		    if (/\$\(add-to-dep:([[:print:]]*)\)/) {
			if (exists($h{$1})) {
			    $m = $h{$1};
			    @tmp = @{$d{$m}};
			    push(@tmp,$f);
			    $d{$m} = [@tmp];
			}
		    }
		    if (/\$\(add-rule:([[:print:]]*)\)/) {
			$m = ":rule:$1";
			@tmp = @{$d{$f}};
			push(@tmp,$m);
			$d{$f} = [@tmp];
		    }
		}
		close(FILEH);
	    }
	    else {
		print "opening \"$_\": $!\n";
	    }
	}
    }
}

print ("# Automatically generated by \"make dep\"\n");
%f = ();
foreach $k (sort keys %d) {
    
    ($fn,$pn) = splitpath($k);
    $f{$fn} = "$pn/$fn";
    
    $tf = tagfile($k);
    print ("$tf: work tags ");
    @tmp = @{$d{$k}};
    foreach $f (@tmp) {
	if (exists($trans{$f})) {
	    print STDERR ("Trans $f:\n");
	    $l = readin($k);
	    @tmp2 = @{$trans{$f}};
	    foreach $e (@tmp2) {
		$dn = compname($e);
		if (!($dn eq compname($k))) {
		    if ($l =~ /[a-zA-Z0-9_][[:space:]\n\r]*:[[:space:]]*$dn[[:space:]\n\r]/) {
			print STDERR ("Found $dn in $k\n");
			print (" ".tagfile($e));
		    }
		}
	    }
	} 
	if ($f =~ /^:rule:/i) {
	    $f =~ s/^:rule://gi;
	    print (" ".$f);
	}
	elsif (!(compname($f) eq compname($k))) {
	    print (" ".tagfile($f));
	}
    }
    if (exists($noread{$k})) {
	print (" $k\n\n");
    }
    else {
	print (" $k\n\t\$(VCOM) $k\n\t\@touch $tf\n");
    }
}

foreach $k (sort keys %f) {
    $n = $k;
    $n =~ s/\.vhd$//gi;
    print ("$n: ".tagfile($f{$k})."\n");
}

print <<MAKEFILE_END;
tags : 
\t\@mkdir tags
work : 
\t\$(if \$(shell \@ls work), ,\$(VLIB) work)
 
MAKEFILE_END


sub tagfile() {
    my ($n) = @_;
    $n =~ s/\//_/gi;
    $n =~ s/\.vhd$//gi;
    $n = "tags/$n";
    return $n;
}

sub compname() {
    my ($n) = @_;
    my ($f,$p) = splitpath($n);
    $f =~ s/\.vhd$//gi;
    return $f;
}
	
sub splitpath() {
    my ($n) = @_;
    my @n = split("/",$n);
    if ($#n > -1) {
	my $f = splice(@n,$#n,1);
	my $p = join("/",@n);
	return ($f,$p);
    }
    return $n;
}


sub readin() {
    my ($n) = @_;
    my $l = "";
    if (open(RF, "$n")) {
	while (<RF>) {
	    $l .= $_;
	}
	close(RF);
    }
    return $l;
}


