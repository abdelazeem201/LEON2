; Konrad Eisele <eiselekd@web.de>
; cdef_lib_i1.el: Some insn functions
;-----------------------------------------------------------------------

(defun is-decoder (l)
  (and (listp l) (eq (length l) 5) (hash-table-p (nth 3 l))))

(defun space-string (n c)
  (let ((str "")
	(e 0))
    (dotimes (e n)
      (setq str (concat str c))
    )
    `,str
  )
)

(defun print-decode-hash (dec depth)
  (cond 
     ((hash-table-p dec)
     (let ((p ""))
       ( maphash (function (lambda (k v)
	 (let ((p2 ""))
	   (setq p2 (concat p2 (space-string (- depth 1) "|") "+" (mapconcat 'number-to-string k "" ) "=" ))
	   (if (is-decoder v)
	       (setq p2 (concat p2 "\n" (print-decoder v depth)))
	       (setq p2 (concat p2 (mapconcat 'symbol-name v "," ) "\n"))
	   )
	   (setq p (concat p p2))
	 ))) dec )
       `,p
     ))
     ((listp dec)
      (mapconcat 'print-list dec " ")
     )
     ((t) ('"?")))
)

(defun print-decoder (d depth)
  (let ((l (- 31 (nth 1 d)))
	(r (+ (- 31 (nth 2 d)) 1))
	(dec (nth 3 d))
	(def (nth 4 d))
        (p ""))
    (if (not (and (eq l 31) (eq r 32)))
        (progn
	  (setq p (concat p (space-string depth "|") "[" (number-to-string l) "-" (number-to-string r) "]\n"  ))
	  (setq p (concat p (print-decode-hash dec (+ 1 depth) )))
        )
    )
    (if (eq (length def) 5)
	(if (and (eq (nth 0 def) 0) (eq (nth 1 def) 0) (> (length (nth 4 def)) 0))
	    (setq p (concat p (space-string depth "|") "+" "def=" (mapconcat 'symbol-name (nth 4 def)  " ") "\n" ))
	    (setq p (concat p (space-string depth "|") "+" "def=\n" (print-decoder def depth)))
	)
    )
    `,p
  )
)

(defun or-insn-set (insn) 
  (let ((e '())
	(v '())
	(m '()))
    (dolist (e insn v)
      (if (eq v '())
	(setq v (make-setbit-groups (make-set-bitstring (symbol-value e))))
	(setq v (or-setbit-groups  v (make-setbit-groups (make-set-bitstring (symbol-value e))) ))
      )
    )
  )
)

(defun insn-max-setenc-set-acc (start end i)
  (let ((a '())
        (v '())
	(e '()))
    (mapcar (function (lambda (x)
       (if (cmp* (cut-copy-list (make-set-bitstring (symbol-value x)) start end) 1)
	   (setq a (cons x a)))
       )) i)
    `,a
    )
  )


;cc: (( 0 0 0) (1 1) (0 0))
;i: 1           x
;(clear-setenc-set '(( 0 0 0) (1 1) (1 1)) 1)
(defun clear-setenc-set (cc i)
  (let ((e '())
	(v '())
	(j 0))
    (dolist (e cc v)
      (if (eq i j)
	  (setq v (append `(,(make-list (length e) 0)) v))
	  (setq v (append `(,e) v))
      )
      (setq j (1+ j))
    )
    (reverse v)
  )
)

(defun setenc-set-p (cc)
  ; check weater a setbit set is remaining
  (let ((e '())
	(v '()))
    (dolist (e cc v)
      (if (eq (nth 0 e) 1)
	(setq v 't)
      )
    )
  )
)


; returns: (ccindex ((insn set)(insn set complement)))
(defun insn-max-setenc-set (cc insn)
  "Resturn row encode set that has the most members" 
  (let ((a (mapcar-setbit 'insn-max-setenc-set-acc cc insn))
	(v '())
	(e '())
	(i 0)
	(j -1)
	(off 0))
    (dolist (e a v)
      (if (not (memq 'nil e))
	  (if (> (length e)(length v)) 
	      (progn 
		(setq v e)
		(setq j i)
	      )
          )
      )
      (setq i (+ i 1))
    )
    `(,j ( ,v ,(remq* v insn) ) )
  )
)

;cc: ((0 0 0) (1 1) (1) (0 0 0))
;i: 1          x
;r: (3 5)
;(insn-get-encrange '((0 0 0) (1 1) (1) (0 0 0)) 1)

(defun insn-get-encrange (cc i)
  ;get range of index <i> if bitset cc 
  (let ((j 0)
	(off 0)
	(end 0))
    (dotimes (j i off) 
      (setq off (+ off (length (nth j cc)))) )
    (setq end (+ off (length (nth i cc))))
    `(,off ,end)
  )
)

(defun get-insn-enc (insn start end)
  ;get the encod value of insn
  (cut-copy-list (symbol-value insn) start end)
)

(defun create-decoder-setenc (cc insnset depth) 
  (let ((i 0)
	(start 0)
	(insn '())
	(insnc '())
	(end 0)
	(range '())
	(nset '())
	(nkey '())
	(nval '())
	(dec)
	(defdec insnset)
	)
    (if (setenc-set-p cc)
	(progn
	  (setq range (insn-max-setenc-set cc insnset))
	  (setq i (nth 0 range))
	  (setq insn (nth 0 (nth 1 range)))
	  (setq insnc (nth 1 (nth 1 range)))
	  (setq start (nth 0 (insn-get-encrange cc i)))
	  (setq end (nth 1 (insn-get-encrange cc i)))
	  
	  (define-hash-table-test 'contents-hash 'equal 'sxhash)
	  (setq dec (make-hash-table :test 'contents-hash))
	  (let ((e '())
		(k '())
		(v '())
		)
	    (dolist (e insn)
	      (setq k (get-insn-enc e start end))
	      (puthash k (cons e (gethash k dec '())) dec )
	      )
	    )
	  (setq nset (clear-setenc-set cc i))
	  (maphash (function (lambda (k v)
	     (if (setenc-set-p (and-setbit-groups nset (or-insn-set v)))
		 (puthash k (create-decoder-setenc (and-setbit-groups nset (or-insn-set v) ) v (+ 1 depth)) dec)
	     )
	  )) dec)
	  (setq defdec '())
          (if (> (length insnc) 0)
	      (setq defdec (create-decoder-setenc (and-setbit-groups nset (or-insn-set insnc)  ) insnc (+ 1 depth)))
	  )
        )
    )
    `(,i ,start ,end ,dec ,defdec ) ;defdec
  )
)


;-----------------------------------------------------------------------

